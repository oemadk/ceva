import * as tslib_1 from "tslib";
/**
 * @name responsive-size-info.directive
 * @description Responsive Size Info directive in ngx-responsive
 *
 * @license MIT
 */
import { Directive, EventEmitter, Input, Output, ViewContainerRef, ChangeDetectorRef } from '@angular/core';
import { PLATFORM_ID, Inject } from '@angular/core';
import { ResponsiveState } from '../../@core/providers/responsive-state/responsive-state';
import { ResponsiveSizeInfo } from './responsive-size-info';
let ResponsiveSizeInfoDirective = class ResponsiveSizeInfoDirective extends ResponsiveSizeInfo {
    constructor(_responsiveState, viewContainer, cd, _platformId) {
        super(_responsiveState, _platformId);
        this._responsiveState = _responsiveState;
        this.viewContainer = viewContainer;
        this.cd = cd;
        this._platformId = _platformId;
        this.statechanges = new EventEmitter();
    }
    set responsiveSizeInfo(grid_state) {
        this._updateData(this.currentstate);
    }
    ngOnInit() {
        this.connect();
    }
    ngOnDestroy() {
        this.disconnect();
    }
    _updateData(value) {
        this.statechanges.emit(value);
        this.cd.markForCheck();
    }
};
tslib_1.__decorate([
    Input(),
    tslib_1.__metadata("design:type", Object),
    tslib_1.__metadata("design:paramtypes", [Object])
], ResponsiveSizeInfoDirective.prototype, "responsiveSizeInfo", null);
tslib_1.__decorate([
    Output(),
    tslib_1.__metadata("design:type", EventEmitter)
], ResponsiveSizeInfoDirective.prototype, "statechanges", void 0);
ResponsiveSizeInfoDirective = tslib_1.__decorate([
    Directive({ selector: 'responsiveSizeInfo' }),
    tslib_1.__param(3, Inject(PLATFORM_ID)),
    tslib_1.__metadata("design:paramtypes", [ResponsiveState,
        ViewContainerRef,
        ChangeDetectorRef, Object])
], ResponsiveSizeInfoDirective);
export { ResponsiveSizeInfoDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoicmVzcG9uc2l2ZS1zaXplLWluZm8uZGlyZWN0aXZlLmpzIiwic291cmNlUm9vdCI6Im5nOi8vbmd4LXJlc3BvbnNpdmUvIiwic291cmNlcyI6WyJAZGlyZWN0aXZlcy9yZXNwb25zaXZlLXNpemUtaW5mby9yZXNwb25zaXZlLXNpemUtaW5mby5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7OztHQUtHO0FBQ0gsT0FBTyxFQUFFLFNBQVMsRUFBRSxZQUFZLEVBQUUsS0FBSyxFQUFFLE1BQU0sRUFBRSxnQkFBZ0IsRUFBcUIsaUJBQWlCLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFDL0gsT0FBTyxFQUFFLFdBQVcsRUFBRSxNQUFNLEVBQUUsTUFBTSxlQUFlLENBQUM7QUFFcEQsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLHlEQUF5RCxDQUFDO0FBQzFGLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLHdCQUF3QixDQUFDO0FBRzVELElBQWEsMkJBQTJCLEdBQXhDLE1BQWEsMkJBQTRCLFNBQVEsa0JBQWtCO0lBTy9ELFlBQW1CLGdCQUFpQyxFQUN6QyxhQUErQixFQUMvQixFQUFxQixFQUNHLFdBQVc7UUFDMUMsS0FBSyxDQUFDLGdCQUFnQixFQUFFLFdBQVcsQ0FBQyxDQUFDO1FBSnRCLHFCQUFnQixHQUFoQixnQkFBZ0IsQ0FBaUI7UUFDekMsa0JBQWEsR0FBYixhQUFhLENBQWtCO1FBQy9CLE9BQUUsR0FBRixFQUFFLENBQW1CO1FBQ0csZ0JBQVcsR0FBWCxXQUFXLENBQUE7UUFMcEMsaUJBQVksR0FBc0IsSUFBSSxZQUFZLEVBQUUsQ0FBQztJQU1yQixDQUFDO0lBVGxDLElBQUksa0JBQWtCLENBQUMsVUFBNkI7UUFDekQsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsWUFBWSxDQUFDLENBQUM7SUFDeEMsQ0FBQztJQVFELFFBQVE7UUFDSixJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUNELFdBQVc7UUFDUCxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUNTLFdBQVcsQ0FBQyxLQUFVO1FBQzVCLElBQUksQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDO1FBQzlCLElBQUksQ0FBQyxFQUFFLENBQUMsWUFBWSxFQUFFLENBQUM7SUFDM0IsQ0FBQztDQUNKLENBQUE7QUFwQlk7SUFBUixLQUFLLEVBQUU7OztxRUFFUDtBQUNTO0lBQVQsTUFBTSxFQUFFO3NDQUFlLFlBQVk7aUVBQTJCO0FBTHRELDJCQUEyQjtJQUR2QyxTQUFTLENBQUMsRUFBRSxRQUFRLEVBQUUsb0JBQW9CLEVBQUUsQ0FBQztJQVdyQyxtQkFBQSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUE7NkNBSGEsZUFBZTtRQUMxQixnQkFBZ0I7UUFDM0IsaUJBQWlCO0dBVHZCLDJCQUEyQixDQXNCdkM7U0F0QlksMkJBQTJCIiwic291cmNlc0NvbnRlbnQiOlsiLyoqXHJcbiAqIEBuYW1lIHJlc3BvbnNpdmUtc2l6ZS1pbmZvLmRpcmVjdGl2ZVxyXG4gKiBAZGVzY3JpcHRpb24gUmVzcG9uc2l2ZSBTaXplIEluZm8gZGlyZWN0aXZlIGluIG5neC1yZXNwb25zaXZlXHJcbiAqXHJcbiAqIEBsaWNlbnNlIE1JVFxyXG4gKi9cclxuaW1wb3J0IHsgRGlyZWN0aXZlLCBFdmVudEVtaXR0ZXIsIElucHV0LCBPdXRwdXQsIFZpZXdDb250YWluZXJSZWYsIE9uSW5pdCwgT25EZXN0cm95LCBDaGFuZ2VEZXRlY3RvclJlZiB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5pbXBvcnQgeyBQTEFURk9STV9JRCwgSW5qZWN0IH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XHJcblxyXG5pbXBvcnQgeyBSZXNwb25zaXZlU3RhdGUgfSBmcm9tICcuLi8uLi9AY29yZS9wcm92aWRlcnMvcmVzcG9uc2l2ZS1zdGF0ZS9yZXNwb25zaXZlLXN0YXRlJztcclxuaW1wb3J0IHsgUmVzcG9uc2l2ZVNpemVJbmZvIH0gZnJvbSAnLi9yZXNwb25zaXZlLXNpemUtaW5mbyc7XHJcblxyXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdyZXNwb25zaXZlU2l6ZUluZm8nIH0pXHJcbmV4cG9ydCBjbGFzcyBSZXNwb25zaXZlU2l6ZUluZm9EaXJlY3RpdmUgZXh0ZW5kcyBSZXNwb25zaXZlU2l6ZUluZm8gaW1wbGVtZW50cyBPbkluaXQsIE9uRGVzdHJveSB7XHJcbiAgICBwdWJsaWMgY3VycmVudHN0YXRlOiBzdHJpbmc7XHJcbiAgICBASW5wdXQoKSBzZXQgcmVzcG9uc2l2ZVNpemVJbmZvKGdyaWRfc3RhdGU6IHN0cmluZ1tdIHwgc3RyaW5nKSB7XHJcbiAgICAgICAgdGhpcy5fdXBkYXRlRGF0YSh0aGlzLmN1cnJlbnRzdGF0ZSk7XHJcbiAgICB9XHJcbiAgICBAT3V0cHV0KCkgc3RhdGVjaGFuZ2VzOiBFdmVudEVtaXR0ZXI8YW55PiA9IG5ldyBFdmVudEVtaXR0ZXIoKTtcclxuXHJcbiAgICBjb25zdHJ1Y3RvcihwdWJsaWMgX3Jlc3BvbnNpdmVTdGF0ZTogUmVzcG9uc2l2ZVN0YXRlLFxyXG4gICAgICAgIHB1YmxpYyB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxyXG4gICAgICAgIHB1YmxpYyBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICAgICAgQEluamVjdChQTEFURk9STV9JRCkgcHJvdGVjdGVkIF9wbGF0Zm9ybUlkXHJcbiAgICApIHsgc3VwZXIoX3Jlc3BvbnNpdmVTdGF0ZSwgX3BsYXRmb3JtSWQpOyB9XHJcbiAgICBuZ09uSW5pdCgpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcclxuICAgIH1cclxuICAgIG5nT25EZXN0cm95KCk6IHZvaWQge1xyXG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIF91cGRhdGVEYXRhKHZhbHVlOiBhbnkpOiB2b2lkIHtcclxuICAgICAgICB0aGlzLnN0YXRlY2hhbmdlcy5lbWl0KHZhbHVlKTtcclxuICAgICAgICB0aGlzLmNkLm1hcmtGb3JDaGVjaygpO1xyXG4gICAgfVxyXG59XHJcbiJdfQ==