import * as tslib_1 from "tslib";
/**
 * @name orientation-info.directive
 * @description Device orientation directive in ngx-responsive
 *
 * @license MIT
 */
import { EventEmitter, Directive, Output, ViewContainerRef, ChangeDetectorRef } from '@angular/core';
import { PLATFORM_ID, Inject } from '@angular/core';
import { ResponsiveState } from '../../@core/providers/responsive-state/responsive-state';
import { OrientationInfo } from './orientation-info';
var OrientationInfoDirective = /** @class */ (function (_super) {
    tslib_1.__extends(OrientationInfoDirective, _super);
    function OrientationInfoDirective(_responsiveState, viewContainer, cd, _platformId) {
        var _this = _super.call(this, _responsiveState, _platformId) || this;
        _this._responsiveState = _responsiveState;
        _this.viewContainer = viewContainer;
        _this.cd = cd;
        _this._platformId = _platformId;
        _this.orientation = new EventEmitter();
        return _this;
    }
    OrientationInfoDirective.prototype.ngOnInit = function () {
        this.connect();
    };
    OrientationInfoDirective.prototype.ngOnDestroy = function () {
        this.disconnect();
    };
    OrientationInfoDirective.prototype._updateData = function (value) {
        this.orientation.emit(value);
        this.cd.markForCheck();
    };
    tslib_1.__decorate([
        Output(),
        tslib_1.__metadata("design:type", EventEmitter)
    ], OrientationInfoDirective.prototype, "orientation", void 0);
    OrientationInfoDirective = tslib_1.__decorate([
        Directive({ selector: 'orientation-info' }),
        tslib_1.__param(3, Inject(PLATFORM_ID)),
        tslib_1.__metadata("design:paramtypes", [ResponsiveState,
            ViewContainerRef,
            ChangeDetectorRef, Object])
    ], OrientationInfoDirective);
    return OrientationInfoDirective;
}(OrientationInfo));
export { OrientationInfoDirective };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoib3JpZW50YXRpb24taW5mby5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9uZ3gtcmVzcG9uc2l2ZS8iLCJzb3VyY2VzIjpbIkBkaXJlY3RpdmVzL2RldmljZXMvb3JpZW50YXRpb24taW5mby5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBOzs7OztHQUtHO0FBQ0gsT0FBTyxFQUFFLFlBQVksRUFBRSxTQUFTLEVBQUUsTUFBTSxFQUFFLGdCQUFnQixFQUFxQixpQkFBaUIsRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUN4SCxPQUFPLEVBQUUsV0FBVyxFQUFFLE1BQU0sRUFBRSxNQUFNLGVBQWUsQ0FBQztBQUVwRCxPQUFPLEVBQUUsZUFBZSxFQUFFLE1BQU0seURBQXlELENBQUM7QUFDMUYsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLG9CQUFvQixDQUFDO0FBR3JEO0lBQThDLG9EQUFlO0lBRXpELGtDQUFzQixnQkFBaUMsRUFDekMsYUFBK0IsRUFDL0IsRUFBcUIsRUFDQSxXQUFXO1FBSDlDLFlBSUksa0JBQU0sZ0JBQWdCLEVBQUUsV0FBVyxDQUFDLFNBQUc7UUFKckIsc0JBQWdCLEdBQWhCLGdCQUFnQixDQUFpQjtRQUN6QyxtQkFBYSxHQUFiLGFBQWEsQ0FBa0I7UUFDL0IsUUFBRSxHQUFGLEVBQUUsQ0FBbUI7UUFDQSxpQkFBVyxHQUFYLFdBQVcsQ0FBQTtRQUo3QixpQkFBVyxHQUFzQixJQUFJLFlBQVksRUFBRSxDQUFDOztJQUszQixDQUFDO0lBQzNDLDJDQUFRLEdBQVI7UUFDSSxJQUFJLENBQUMsT0FBTyxFQUFFLENBQUM7SUFDbkIsQ0FBQztJQUNELDhDQUFXLEdBQVg7UUFDSSxJQUFJLENBQUMsVUFBVSxFQUFFLENBQUM7SUFDdEIsQ0FBQztJQUNTLDhDQUFXLEdBQXJCLFVBQXNCLEtBQVU7UUFDNUIsSUFBSSxDQUFDLFdBQVcsQ0FBQyxJQUFJLENBQUMsS0FBSyxDQUFDLENBQUM7UUFDN0IsSUFBSSxDQUFDLEVBQUUsQ0FBQyxZQUFZLEVBQUUsQ0FBQztJQUMzQixDQUFDO0lBZlM7UUFBVCxNQUFNLEVBQUU7MENBQXFCLFlBQVk7aUVBQTJCO0lBRDVELHdCQUF3QjtRQURwQyxTQUFTLENBQUMsRUFBRSxRQUFRLEVBQUUsa0JBQWtCLEVBQUUsQ0FBQztRQU1uQyxtQkFBQSxNQUFNLENBQUMsV0FBVyxDQUFDLENBQUE7aURBSGdCLGVBQWU7WUFDMUIsZ0JBQWdCO1lBQzNCLGlCQUFpQjtPQUoxQix3QkFBd0IsQ0FpQnBDO0lBQUQsK0JBQUM7Q0FBQSxBQWpCRCxDQUE4QyxlQUFlLEdBaUI1RDtTQWpCWSx3QkFBd0IiLCJzb3VyY2VzQ29udGVudCI6WyIvKipcclxuICogQG5hbWUgb3JpZW50YXRpb24taW5mby5kaXJlY3RpdmVcclxuICogQGRlc2NyaXB0aW9uIERldmljZSBvcmllbnRhdGlvbiBkaXJlY3RpdmUgaW4gbmd4LXJlc3BvbnNpdmVcclxuICpcclxuICogQGxpY2Vuc2UgTUlUXHJcbiAqL1xyXG5pbXBvcnQgeyBFdmVudEVtaXR0ZXIsIERpcmVjdGl2ZSwgT3V0cHV0LCBWaWV3Q29udGFpbmVyUmVmLCBPbkluaXQsIE9uRGVzdHJveSwgQ2hhbmdlRGV0ZWN0b3JSZWYgfSBmcm9tICdAYW5ndWxhci9jb3JlJztcclxuaW1wb3J0IHsgUExBVEZPUk1fSUQsIEluamVjdCB9IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgUmVzcG9uc2l2ZVN0YXRlIH0gZnJvbSAnLi4vLi4vQGNvcmUvcHJvdmlkZXJzL3Jlc3BvbnNpdmUtc3RhdGUvcmVzcG9uc2l2ZS1zdGF0ZSc7XHJcbmltcG9ydCB7IE9yaWVudGF0aW9uSW5mbyB9IGZyb20gJy4vb3JpZW50YXRpb24taW5mbyc7XHJcblxyXG5ARGlyZWN0aXZlKHsgc2VsZWN0b3I6ICdvcmllbnRhdGlvbi1pbmZvJyB9KVxyXG5leHBvcnQgY2xhc3MgT3JpZW50YXRpb25JbmZvRGlyZWN0aXZlIGV4dGVuZHMgT3JpZW50YXRpb25JbmZvIGltcGxlbWVudHMgT25Jbml0LCBPbkRlc3Ryb3kge1xyXG4gICAgQE91dHB1dCgpIHB1YmxpYyBvcmllbnRhdGlvbjogRXZlbnRFbWl0dGVyPGFueT4gPSBuZXcgRXZlbnRFbWl0dGVyKCk7XHJcbiAgICBjb25zdHJ1Y3Rvcihwcm90ZWN0ZWQgX3Jlc3BvbnNpdmVTdGF0ZTogUmVzcG9uc2l2ZVN0YXRlLFxyXG4gICAgICAgIHByb3RlY3RlZCB2aWV3Q29udGFpbmVyOiBWaWV3Q29udGFpbmVyUmVmLFxyXG4gICAgICAgIHByb3RlY3RlZCBjZDogQ2hhbmdlRGV0ZWN0b3JSZWYsXHJcbiAgICAgICAgQEluamVjdChQTEFURk9STV9JRCkgcHJvdGVjdGVkIF9wbGF0Zm9ybUlkXHJcbiAgICApIHsgc3VwZXIoX3Jlc3BvbnNpdmVTdGF0ZSwgX3BsYXRmb3JtSWQpOyB9XHJcbiAgICBuZ09uSW5pdCgpIHtcclxuICAgICAgICB0aGlzLmNvbm5lY3QoKTtcclxuICAgIH1cclxuICAgIG5nT25EZXN0cm95KCkge1xyXG4gICAgICAgIHRoaXMuZGlzY29ubmVjdCgpO1xyXG4gICAgfVxyXG4gICAgcHJvdGVjdGVkIF91cGRhdGVEYXRhKHZhbHVlOiBhbnkpIHtcclxuICAgICAgICB0aGlzLm9yaWVudGF0aW9uLmVtaXQodmFsdWUpO1xyXG4gICAgICAgIHRoaXMuY2QubWFya0ZvckNoZWNrKCk7XHJcbiAgICB9XHJcbn1cclxuIl19